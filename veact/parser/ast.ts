import VSXVisitor from "@/veact/visitor";
import type { VEACTree } from "@/veact/types/tree";
import type { VEACTagElement } from "@/veact/types/elements";
import VSXCSTParser from "./cst";
import vreactLexer from "./lexer";
import { strip } from "@/utils/strip";

export default class VSXASTParser {
    private visitor: VSXVisitor;

    constructor() {
        this.visitor = new VSXVisitor();
    }

    public parse(code: string): VEACTree & { astTree: any } {
        // First strip the code and tokenize the code
        const strippedCode = strip(code);
        console.log("Stripped code:", strippedCode);
        
        const tokens = vreactLexer.tokenize(strippedCode);
        console.log("Tokens:", JSON.stringify(tokens.tokens.slice(0, 5), null, 2));
        
        // Second parse the tokens into a CST
        const parser = new VSXCSTParser();
        parser.input = tokens.tokens;
        const cst = parser.function();
        console.log("CST:", JSON.stringify(cst, null, 2));

        // Third visit the CST and return the AST
        const vsxRoot = this.visitor.visit(cst);
        console.log("VSX Root:", JSON.stringify(vsxRoot, null, 2));

        // Convert the VSX AST generated by the visitor into a VEACTree so the rest of the
        // application can work with a simplified uniform structure.
        const tree = this.#vsxNodeToVEACTree(vsxRoot);
        
        // Create and attach the AST tree representation
        const astTree = {
            root: tree.root,
            childrenCount: tree.children.length,
            allElements: [
                tree.root,
                ...tree.children
            ]
        };
        
        return {
            ...tree,
            astTree
        };
    }

    /**
     * Recursively walks the VSX AST tree and converts every node into a VEACTagElement while
     * collecting them into the children Set of the final VEACTree instance.
     */
    #vsxNodeToVEACTree(rootNode: any): VEACTree {
        // The visitor currently returns `any` â€“ we defensively check the required fields.
        if (!rootNode || typeof rootNode !== "object") {
            throw new Error("Visitor did not return a valid VSXNode AST");
        }

        // Create a more complete tree structure by recursively walking the AST
        // and keeping track of parent-child relationships
        const allElements: VEACTagElement[] = [];
        const rootElement = this.#createTagElementWithChildren(rootNode, allElements);

        return {
            root: rootElement,
            children: allElements
        };
    }

    #createTagElementWithChildren(node: any, allElements: VEACTagElement[]): VEACTagElement {
        const element: VEACTagElement = {
            name: node.tag ?? "unknown",
            type: "tag",
            children: []
        };

        // Initialize attributes object if needed
        if (!element.attributes) {
            element.attributes = {};
        }

        // Add content as an attribute if present and non-empty
        if (node.content && node.content.trim()) {
            element.attributes.content = node.content;
        }

        // Copy other attributes from node if present
        if (node.attributes && typeof node.attributes === 'object') {
            element.attributes = {
                ...element.attributes,
                ...node.attributes
            };
        }

        // Process children (we initialize children in the element creation above)
        if (Array.isArray(node.children) && node.children.length > 0) {
            for (const child of node.children) {
                const childElement = this.#createTagElementWithChildren(child, allElements);
                element.children!.push(childElement);
                allElements.push(childElement);
            }
        }

        return element;
    }
}

