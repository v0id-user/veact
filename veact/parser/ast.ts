import VSXVisitor from "@/veact/visitor";
import type { VEACTree } from "@/veact/types/tree";
import type { VEACTagElement } from "@/veact/types/elements";
import VSXCSTParser from "./cst";
import vreactLexer from "./lexer";
import { strip } from "@/utils/strip";

export default class VSXASTParser {
    private visitor: VSXVisitor;

    constructor() {
        this.visitor = new VSXVisitor();
    }

    public parse(code: string): VEACTree {
        // First strip the code and tokenize the code
        const tokens = vreactLexer.tokenize(strip(code));
        
        // Second parse the tokens into a CST
        const parser = new VSXCSTParser();
        parser.input = tokens.tokens;
        const cst = parser.function();

        // Third visit the CST and return the AST
        const vsxRoot = this.visitor.visit(cst);

        // Convert the VSX AST generated by the visitor into a VEACTree so the rest of the
        // application can work with a simplified uniform structure.
        const tree = this.#vsxNodeToVEACTree(vsxRoot);
        return tree;
    }

    /**
     * Recursively walks the VSX AST tree and converts every node into a VEACTagElement while
     * collecting them into the children Set of the final VEACTree instance.
     */
    #vsxNodeToVEACTree(rootNode: any): VEACTree {
        // The visitor currently returns `any` â€“ we defensively check the required fields.
        if (!rootNode || typeof rootNode !== "object") {
            throw new Error("Visitor did not return a valid VSXNode AST");
        }

        // Create a more complete tree structure by recursively walking the AST
        // and keeping track of parent-child relationships
        const allElements: VEACTagElement[] = [];
        const rootElement = this.#createTagElementWithChildren(rootNode, allElements);

        return {
            root: rootElement,
            children: allElements
        };
    }

    #createTagElementWithChildren(node: any, allElements: VEACTagElement[]): VEACTagElement {
        const element: VEACTagElement = {
            name: node.tag ?? "unknown",
            type: "tag",
            children: []
        };

        // Add content as an attribute if present and non-empty
        if (node.content && node.content.trim()) {
            element.attributes = {
                content: node.content
            };
        }

        // Process children (we initialize children in the element creation above)
        if (Array.isArray(node.children) && node.children.length > 0) {
            for (const child of node.children) {
                const childElement = this.#createTagElementWithChildren(child, allElements);
                element.children!.push(childElement);
                allElements.push(childElement);
            }
        }

        return element;
    }

    #createTagElement(node: any): import("@/veact/types/elements").VEACTagElement {
        return {
            name: node.tag ?? "unknown",
            type: "tag"
        };
    }
}

